# TypeScript compiler

## Program

The project coordinator:

- `Read the TSConfig`: setup the program, get starting files
- `Pre-process files`: follow imports to discover all possible files
- `Tokenize and Parse`: convert text to a syntax tree
- `Binder`: convert identifiers in syntax tree to symbols
- `Type Check`: use binder and syntax tree to look for issues in code
- `Transform`: changes the syntax tree to match tsconfig options
- `Emit`: prints the syntax tree into .js, .d.ts, and other files

Let's see how tht API looks like:

```typescript
import * as ts from 'typescript';

// code to syntax tree
const program = ts.createProgram(files, opts);

// binding and type checking
const checker = program.getTypeChecker();

// syntax tree to code
program.emit();
```

## Source code to data

Converting code to a syntax tree

```typescript
function welcome(str: string) {
  console.log(str);
}

const msg: string = 'Hello, World!';

welcome(msg); // Hello, World!
```

It creates the syntax tree using a [scanner](https://github.com/microsoft/TypeScript/blob/main/src/compiler/scanner.ts) and and a [parser](https://github.com/microsoft/TypeScript/blob/main/src/compiler/parser.ts).

### Scanner

The `scanner` receives the text (source code) and outputs a sequence of tokens.

```typescript
const msg: string = 'Hello, World';
```

It transforms this source code into tokens like this:

`ConstKeyword` `WhitespaceTrivia` `Identifier` `ColonToken` `WhitespaceTrivia` `StringKeyword` `WhitespaceTrivia` `EqualsToken` `WhitespaceTrivia` ...

The `scanner` also has diagnostics, an expressive way to show users their JavaScript/TypeScript code is invalid, has errors, or is missing any thing.

No closing quote to the open quote:

```typescript
const noEnd = '; // => Unterminated string literal.
```

An invalid character:

```typescript
const ðŸ‡¯ðŸ‡µ = 'Japan Flag'; // Invalid character
```

Numeric separators can't be consecutive:

```typescript
const num = 1__0; // Multiple consecutive numeric separators are not permitted.
```

And so on.

### Parser

The `parser` gets the tokens generated by the `scanner` and creates the syntax tree.

A simple example of a syntax tree is the representation of a variable declaration. Given this source code:

```typescript
const num = 10;
```

The `parser` will generate this syntax tree:

```
SourceFile
  - VariableStatement
    - VariableDeclarationList
      - VariableDeclaration
        - Identifier
        - NumericLiteral
  - EndOfFileToken
```

The `VariableStatement` has a list of `VariableDeclaration`, which has the `Identifier` (`num`) and the `NumericLiteral` (`10`).

There's a [cool AST playground](https://ts-ast-viewer.com/) we can use to have a better understanding on how the source code and the generated syntax tree are related one to another.

The `parser` diagnostics shows the "right JavaScript code in the wrong place".

Private identifiers outside of a class:

```typescript
#constant = 10; // The left-hand side of an assignment expression must be a variable or a property access.
```

`BigInt` should be integers not decimals:

```typescript
const decimalBigInt = 1.2n; // A bigint literal must be an integer.
```

Reserved words in JavaScript:

```typescript
const extends = 'extends'; // 'extends' is not allowed as a variable declaration name.
```

And so on.

## Type Checking

### Binder

The `binder` transforms the syntax into symbols.

Processing code, there're different scopes. Let's see an example

```typescript
const msg: string = 'Hello, World!';

function welcome(str: string) {
  console.log(str);
}

welcome(msg);
```

In the global scope, we have the `msg` and the `welcome` variables.

In the function scope, we have the `str` variable.

Symbols are tables for each scope in the program to store identifier with its metadata like where it was declared and its flag.

Getting the syntax tree from the previous source code, the `binder` generates these symbol tables:

**Global Scope:**

- `msg`:
  - declared line 0
  - flags:`BlockScopedVariable`
- `welcome`:
  - declared line 6
  - flags: `Function`

**welcome Function Scope:**

- `parent`: Global Scope
- `str`:
  - declared line 2
  - flags: `BlockScopedVariable`

And the `binder` tries to keep track of the identifiers across files.
