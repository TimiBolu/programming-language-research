<samp>

# TypeScript compiler

Notes on how the TypeScript compiler works. Resources I took the notes from:

- [TypeScript codebase](https://github.com/microsoft/typescript)
- [mini-typescript](https://github.com/sandersn/mini-typescript) by [@sandersn](https://github.com/sandersn)
- [How the TypeScript Compiler Compiles](https://www.youtube.com/watch?v=X8k_4tZ16qU) by [@orta](https://github.com/orta)

## Program

The project coordinator:

- `Read the TSConfig`: setup the program, get starting files
- `Pre-process files`: follow imports to discover all possible files
- `Tokenize and Parse`: convert text to a syntax tree
- `Binder`: convert identifiers in syntax tree to symbols
- `Type Check`: use binder and syntax tree to look for issues in code
- `Transform`: changes the syntax tree to match tsconfig options
- `Emit`: prints the syntax tree into .js, .d.ts, and other files

Let's see how tht API looks like:

```typescript
import * as ts from 'typescript';

// code to syntax tree
const program = ts.createProgram(files, opts);

// binding and type checking
const checker = program.getTypeChecker();

// syntax tree to code
program.emit();
```

## Source code to data

Converting code to a syntax tree

```typescript
function welcome(str: string) {
  console.log(str);
}

const msg: string = 'Hello, World!';

welcome(msg); // Hello, World!
```

It creates the syntax tree using a [scanner](https://github.com/microsoft/TypeScript/blob/main/src/compiler/scanner.ts) and and a [parser](https://github.com/microsoft/TypeScript/blob/main/src/compiler/parser.ts).

### Scanner

The `scanner` receives the text (source code) and outputs a sequence of tokens.

```typescript
const msg: string = 'Hello, World';
```

It transforms this source code into tokens like this:

`ConstKeyword` `WhitespaceTrivia` `Identifier` `ColonToken` `WhitespaceTrivia` `StringKeyword` `WhitespaceTrivia` `EqualsToken` `WhitespaceTrivia` ...

The `scanner` also has diagnostics, an expressive way to show users their JavaScript/TypeScript code is invalid, has errors, or is missing any thing.

No closing quote to the open quote:

```typescript
const noEnd = '; // => Unterminated string literal.
```

An invalid character:

```typescript
const ðŸ‡¯ðŸ‡µ = 'Japan Flag'; // Invalid character
```

Numeric separators can't be consecutive:

```typescript
const num = 1__0; // Multiple consecutive numeric separators are not permitted.
```

And so on.

### Parser

The `parser` gets the tokens generated by the `scanner` and creates the syntax tree.

A simple example of a syntax tree is the representation of a variable declaration. Given this source code:

```typescript
const num = 10;
```

The `parser` will generate this syntax tree:

```
SourceFile
  - VariableStatement
    - VariableDeclarationList
      - VariableDeclaration
        - Identifier
        - NumericLiteral
  - EndOfFileToken
```

The `VariableStatement` has a list of `VariableDeclaration`, which has the `Identifier` (`num`) and the `NumericLiteral` (`10`).

There's a [cool AST playground](https://ts-ast-viewer.com/) we can use to have a better understanding on how the source code and the generated syntax tree are related one to another.

The `parser` diagnostics shows the "right JavaScript code in the wrong place".

Private identifiers outside of a class:

```typescript
#constant = 10; // The left-hand side of an assignment expression must be a variable or a property access.
```

`BigInt` should be integers not decimals:

```typescript
const decimalBigInt = 1.2n; // A bigint literal must be an integer.
```

Reserved words in JavaScript:

```typescript
const extends = 'extends'; // 'extends' is not allowed as a variable declaration name.
```

And so on.

## Type Checking

### Binder

The `binder` transforms the syntax into symbols.

Processing code, there're different scopes. Let's see an example

```typescript
const msg: string = 'Hello, World!';

function welcome(str: string) {
  console.log(str);
}

welcome(msg);
```

In the global scope, we have the `msg` and the `welcome` variables.

In the function scope, we have the `str` variable.

Symbols are tables for each scope in the program to store identifier with its metadata like where it was declared and its flag.

Getting the syntax tree from the previous source code, the `binder` generates these symbol tables:

**Global Scope:**

- `msg`:
  - declared line 0
  - flags:`BlockScopedVariable`
- `welcome`:
  - declared line 6
  - flags: `Function`

**welcome Function Scope:**

- `parent`: Global Scope
- `str`:
  - declared line 2
  - flags: `BlockScopedVariable`

And the `binder` tries to keep track of the identifiers across files.

Another responsibility of the `binder` is to structure the flow nodes. It creates the flow graph to represent each scope and its types. It has different "containers" and each container could have different types for the same variable. Let's see an example.

```typescript
function logValue(x: string | number) {
  if (typeof x === 'string') {
    console.log('string', x);
  } else {
    console.log('number', x);
  }

  x;
}
```

- `logValue` function container
  - `x` with type `string | number`
  - if condition true container
    - `x` with type `string`
  - if condition false container
    - `x` with type `number`
  - `x` again with type `string | number`

The `binder` diagnostics show errors like:

The impossibility to declare a variable with the same naming it was used before for another variable:

```typescript
const num = 1;
const num = 2; // Cannot redeclare block-scoped variable 'num'.
```

When identifiers are duplicated:

```typescript
class User {}
type User = {}; // Duplicate identifier 'User'.
```

### Checker

There're three main systems: how it checks, comparing types, and the inference system.

The `checker` checks each part of the syntax tree.

If we have a simple variable statement:

```typescript
const msg: string = 'test';
```

It results into this syntax tree:

```
SourceFile
  - VariableStatement
    - VariableDeclarationList
      - VariableDeclaration
        - Identifier
        - StringKeyword
        - StringLiteral
  - EndOfFileToken
```

And the `checker` checks each node of the syntax tree.

```typescript
checker
  .checkSourceElementWorker()
  .checkVariableStatement()
  .checkGrammarVariableDeclarationList()
  .checkVariableDeclaration()
  .checkVariableLikeDeclaration()
  .checkTypeAssignableToAndOptionallyElaborate()
  .isTypeRelatedTo(identifier, stringLiteral);
```

And the `checker` considers the source type and target string as the same type and returns `true`.

For type inference, the syntax tree, rather than providing the `StringKeyword`, there's no type given:

```
SourceFile
  - VariableStatement
    - VariableDeclarationList
      - VariableDeclaration
        - Identifier
        // - No type given
        - StringLiteral
  - EndOfFileToken
```

So the `checker` tries to understand the syntax shape to fill in the gaps: From `StringLiteral`, it understands that the type is a string (`StringKeyword`).

## Emitting files

### Emitter

It transforms the syntax tree into files.

- What to emit? e.g. `*.js`, `*.map`, `*.d.ts`
- Printer: syntax tree to text
- Tracking temp vars
- Transformers: syntax tree to syntax tree

Tranforming the syntax tree into a new syntax tree to remove static types. Basically transforming TypeScript into legitimate JavaScript.

```
SourceFile                                        SourceFile
  - VariableStatement                               - VariableStatement
    - VariableDeclarationList                         - VariableDeclarationList
      - VariableDeclaration           --->              - VariableDeclaration
        - Identifier                                      - Identifier
        - StringKeyword                                   // removed type
        - StringLiteral                                   - StringLiteral
  - EndOfFileToken                                  - EndOfFileToken
```

The `emitter` remove the types, emits JavaScript output and `.dts` files (type check them).

</samp>
